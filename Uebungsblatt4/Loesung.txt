Aufgabe 1:
	a) Nein, im Heap.
	b) Ja.
	c) Nein, nur Attribute.
	d) Ja. Private, Public, etc.
	e) Nein.
	f) Nein, nur Erweiterung moeglich.
	g) Nein, nur falls static inner class.
	h) Ja.
	i) Ja.
	j) Ja.
	k) Ja, nur static final.
	l) Geht nicht.
	m) Falsch.

Aufgabe 2:
	Innerhalb eines Block kann geprueft werden ob eine Variable zu beginn
	initialisiert wurde. Innerhalb einer Klasse, kann eine Variable auch in
	einer anderen Methode initialisert werden. Dies ist nicht pruefbar.

Aufgabe 3:
	Nein, da sonst das Standardverhalten von Wertetypen ignoriert wird.

Aufgabe 4:
	Unterklassen benoetigen eventuell Daten die in der Oberklasse initialisiert
	werden.
	Es wird sichergestellt, dass Unterklassen das Verhalten der Oberklasse
	folgen.

Aufgabe 5:
	Wenn es keine Referenz auf das Objekt gibt.

Aufgabe 6:
	Ja, durch die Benutzung von super statt this. Unterklasse muss alles
	koennen was Oberklasse kann.

Aufgabe 7:
	Da es dann definierte Methoden gibt, die nicht implementiert sind.

Aufgabe 8:
	Nein, Konstruktur gibt ein Objekt der eigenen Klasse zurueck.

Aufgabe 9:
	a) Zu keiner. Es gibt einen Compileerror in Zeile 3. Klasse A hat keine
	Methode g().
	b) Compileerror in Zeile 3. Typ A hat keine Methode g.
	c) this.f();
	d) super.g();
	e) this.h();
	f) Geht nicht. super.super geht nicht.

Aufgabe 10:
	A.f()

Aufgabe 11:
	Durch die Definition von Interfaces. Klassen koennen diese Implementieren um
	miteinander zu kommunizieren ohne von einander Wissen zu muessen.
	Vorteile:
		- Vorgabe der Struktur ohne konkrete Implementierung
			==> Framework

Aufgabe 12:
	DISPOSE_ON_CLOSE in WindowConstans definiert und JFrame implementiert dies.
	Die Klasse KundenVerwaltung erbt von JFrame.
